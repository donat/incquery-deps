\chapter{Introduction}
% ------------------------------------------------------------------------------
% 2 pages. give a short overview about the environment and introduce the problem
% what my solution solves.
% ------------------------------------------------------------------------------


\section{Control systems at CERN}

% What is CERN.
The European Organization for Nuclear Research known as CERN is an international
organization which runs the the world's biggest particle physics laboratory.
Established at 1954 and situated on the Swiss-French border next to Geneva. The
organization's main goal to operate particle accelerators (such as the Large
Hadron Collider) and all the necessary infrastructure.

% The Controls group.
Obviously not only physicists work az CERN: numerous scientist and engineers are
working on the design and the maintenance of the software and hardware
equipments in a well-defined structure. The Controls Group is responsible for --
among the others -- the design and implementation of both software and hardware
used in the controls systems. This involves providing software frameworks,
providing alarm systems and communication middleware and numerous related tasks.

% Main goal for Controls group.
After the LHC became operational the number one objective for the Controls Group
is to maintain the operation uninterrupted without any downtime. This implies
that a upgrading certain parts of the system should not interfere with other
component's.

% Controls systems.
The controls systems is a complex, distributed and highly modular system which
has three tiers. On the top there are the GUI applications which are written in
Java. The middle or business layer is also consists of Java applications. On the
lowest or hardware level there are C/C++ applications running on real-time
systems. Maintaining a complex system like this requires a set of special
approaches provide desired quality and maximize the availability of the systems
in one.

\section{Main goal: Smooth upgrades}
% What is a smooth upgrade.
Smooth upgrade means when a software is being updated than all the other
softwares which depend in the upgraded one will remain operational. A basic
example of braking this principle, when the newer version is binary
incompatible with dependant softwares and cause load-time error.

% How to achieve smooth upgrades.
There are a variety of tools and methods how to achieve smooth upgrades. For
instance one can introduce manual procedures and protocols to the development
lifecycle. Another possibility to enforce some code metrics to achieve this
goal.

% One possiblity: incoming dependencies.
The last approach -- which my solution tries to implement -- is the concept of
\emph{incoming dependencies}. As an example let's see a developer who is working
a Java library which happens to be used by some clients. Now let's say there is
an error in the bug which requires a change in the library's API for the
resolution. Our developer obviously wants to know who is using that part of the
API. The users (as in code parts) are considered as incoming dependencies.
 
% My solution.
My solution which I present in this paper is a possible implementation for
querying incoming dependencies. The first valid question is: why didn't we just
reuse an existing implementation? The answer is: because there is no one.
There are specialities about the situation my tool has to solve.
\begin{description}
\item[Size limitation] If we are able to load every single jars into an IDE the
problem would be solved: we could use the internal navigation features to navigate 
through the dependency graph. But because we have thousands of jars (and tens of 
thousands if we count the possible versions) it is evidently impossible.   
\item[Fine-graininess of dependencies] The existing tools usually cannot determine
 the desired dependency resolution level. 
 % TODO: insert link to tattletale.
\item[No source code analysis] We don't want to do a source code analysis because 
it would imply a dependency resolution for concerned projects every time a new version 
of a product comes out. This requirement eliminates a number of possible tools. 
\end{description}

Because of these reasons we decided to implement our own solution called \ptool{}.
In the following chapters I will present the design and the implementation for
this tool and how is it currently applied az CERN Controls Group.

