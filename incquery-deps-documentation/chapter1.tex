\chapter{Introduction}
% ------------------------------------------------------------------------------
% 2 pages. give a short overview about the environment and introduce the problem
% what my solution solves.
% ------------------------------------------------------------------------------

\section{Motivation}

\todo[inline]{context}: complex software development

In today's software development practice
complex projects
many components
large and distributed development teams

aim is to reduce inconsistency issues that arise due to 
conflicting development steps. 


\subsection{Challenge: Smooth upgrades}
% What is a smooth upgrade.

Component-oriented context

A straightforward example of braking this principle,
when the newer version is binary incompatible with dependant softwares and cause
load-time error.

Java: linking errors either at compile time or at runtime

\todo[inline]{preciz smooth upgrade definicio}

The main challenge addressed in this work is to achieve \emph{smooth upgrades}. Smooth upgrade means
when a software is being updated than all the other softwares which depend on it
will remain operational. 


\subsection{Achieving smooth upgrades by dependency analysis}
There are a variety of tools and methods to achieve smooth upgrades. For
instance one can introduce manual procedures and protocols to the development
lifecycle. Another possibility to enforce some code metrics to achieve this
goal.

\todo[inline]{explain the connection between smooth upgrade and dependency analysis}

% One possiblity: incoming dependencies.
The last approach -- which the solution presented in this paper implements -- is
the analysis of \emph{incoming dependencies}. As an example let's say a
developer who is working a Java library which happens to be used by some
clients. Now let's say there is an error in the bug which requires a change in
the library's API for the resolution. Our developer wants to check who is using
the API, which parts are used and should remain unattached and which are the
unused parts. The users (as in code parts) are considered as incoming
dependencies. The following chapters describe an implementation for querying these 
incoming dependencies. 
 


\subsection{Requirements}

\subsubsection{The context of this work: Controls Systems at CERN}
The context of this work is the author's internship at the Controls Group of
CERN, the European Organization for Nuclear Research. CERN runs the the world's
biggest particle physics laboratory with the main goal to operate particle
accelerators (such as the Large Hadron Collider) and all the necessary
infrastructure. At CERN, numerous scientist and engineers are working on the
design and the maintenance of the software and hardware equipment in a
well-defined structure. One of its members is the \emph{Controls Group} which is
responsible for the design and implementation of both software and hardware used
in the controls systems.

The controls system itself is a complex, distributed and highly modular system
which has three tiers. On the top there are the GUI applications which are
written in Java. The middle or business layer is also consists of Java
applications. On the lowest or hardware level there are C/C++ applications
running on real-time systems. Maintaining a complex system like this requires a
set of special approaches in order to provide desired quality and to maximize
the availability of the systems. The primary objective for the Controls Group is
to maintain uninterrupted operation without any downtime. During the internship,
the author was tasked with designing and implementing a developer tool that
should aid the software developers at CERN in minimizing software component
upgrade problems.

\subsubsection{Requirements specific to the deployment environment}
There are certain requirements specific to the software infrastructure at CERN
that needed to be taken into consideration while designing the system.

\begin{description}
\item[Technological environment] The software components to be managed by the
new tool are all plain Java programs that do not make use of any framework (such
as e.g. OSGi) for dependency and lifecycle management, but rely on basic
features of the Java Compiler and the Java Virtual Machine to link to each
other.
 
\item[Complexity of a large software infrastructure] In a simple case,
dependency analysis could be supported by a development environment such as
Eclipse based on integrated source/binary code analysis. However, CERN Controls
Systems deals with an infrastructure that consists of several thousands
components (JARs) and even more if versioning information is taken into
consideration. The resources available for development environments at developer
PCs are not enough for supporting standard IDE features over a system of this
size.
 
\item[Granularity of dependencies] Existing dedicated dependency analysis
tools offer a rather limited feature set for defining dependency relationships.
For example JDepend \cite{JDepend} and JBoss Tattletale \cite{Tattletale} does
dependency analysis on the class level, but CERN's requirement is to see
method-level and fields level dependencies as well.

\item[Source code analysis alone not feasible] Due to legacy reasons at CERN,
the (up-to-date) source code is not available for some software components. In
other cases, the source code is very large in size because it is automatically
generated. Therefore, tools that rely solely on source code analysis cannot be
used.

\end{description}

\section{Overview of the proposed solution}
After analysing available off-the-shelf solutions, it became clear that the
unique requirements called for a custom solution. The result of the work, called
\ptool{}, implements hybrid dependency analysis based on both source and binary
software components, and relies on a client-server architecture where end-user
features are specifically aligned with the computing resources of the host
environment. The tool uses a state-of-the-art incremental model query evaluation
engine called EMF-IncQuery (developed at the Department of Measurement and
Information Systems of the Budapest University of Technology and Economics), to
provide on-the-fly dependency analysis results that can be refined on demand,
integrated into the Eclipse development tool.

\subsection{Server features}

\begin{itemize}
  \item binary dependency discovery based on byte code analysis
  \item dependency database (supported by an RDBMS)
  \item dependency data access layer based on Java RMI
\end{itemize}

\subsection{Client features}

\begin{itemize}
  \item source dependency discovery based on incremental AST processing
  \item model-based dependency representation for both local (source) and remote (binary) dependencies
  \item on-the-fly dependency queries based on the joined local and remote dependency model 
  \item UI integration components for both client-side and server-side queries
\end{itemize}

\section{Structure of the report}
The rest of this report is structured as follows. Chapter 2 gives a brief
overview of technologies that have been used in the design and implementation.
Chapter 3 discusses the role of the tool in development workflow (Section 3.1),
provides a high-level overview of the software system architecture (Section 3.2)
and introduces a running example that is used in explanations later on (Section
3.3). Chapter 4 elaborates the design and implementation details, by discussing
components both on the server side (Section 4.1) and client side (Section 4.2).
Chapter 5 presents experimental results on the performance evaluation of the
system, and Chapter 6 concludes the report with discussing on future work.

\todo[inline]{change for proper refs}


