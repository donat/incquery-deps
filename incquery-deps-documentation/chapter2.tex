\chapter{Background}
%------------------------------------------------------------------------------
%10 pages. For motivation: Design pattern figure. (Service registration pattern).
%------------------------------------------------------------------------------


\section{Related technologies}
% Why do we need this part.
Before proceeding to the main part of this paper, I am going to give an overview
about the related technologies used by my solution. I Why do we have to present
the related technologies.

\subsection{Java Runtime}

\subsubsection{Java byte code specification}
How the java vm works.
What is the input.
What kind of information can be extracted from here.

\subsubsection{Apache Commons Byte Code Engineering Library}
% described in the virtual machine specification 
% http://docs.oracle.com/javase/specs/jvms/se5.0/html/VMSpecTOC.doc.html 
% how the virtual machine works
% what kind of infomration is available in the bytecode 
\cite{BCEL}
Abstraction over Java byte code specification. 
How it works. Create diagram!
Possible use-cases.


\subsection{Eclipse}

\subsubsection{Eclipse Integrated Development Environment}
The Eclipse Project \cite{Eclipseproject} is an open source software development
project dedicated to providing a robust, full-featured, commercial-quality,
industry platform for the development of highly integrated tools. It was
developed by IBM from 1999, and a few months after the first version was
shipped, IBM donated the source code to the Eclipse Foundation.

The Eclipse project consists of many subprojects, the most important being the
Eclipse Platform, that defines the set of frameworks and common services that
collectively make up ,,integration-ware'' required to support a comprehensive
tool integration platform. These services and frameworks represent the common
facilities required by most tool builders, including a standard workbench user
interface and project model for managing resources, portable native widget and
user interface libraries, automatic resource delta management for incremental
compilers and builders, language-independent debug infrastructure, and
infrastructure for distributed multi-user versioned resource management.

The Eclipse Platform has an easily-extendable modular architecture, where all
functionality is achieved by plugins, running over a low-level core called
Platform Runtime. This runtime core is only responsible for loading and
connecting the available plugins, every other functionality, such as the
editors, views, project management, is handled by plugins. The plugins bundled
with Eclipse Platform include general user interface components, a common help
system for all Eclipse components, project management and team work support.

\subsubsection{Eclipse Java Development Tools}
% TODO: Write jdt description with the same details as the Eclipse platform.

\subsubsection{Eclipse Modeling Framework}
The Eclipse Modeling Framework (EMF) \cite{EMF} is a Java framework and code
generation facility for building tools and other applications based on a
structured model. EMF is also maintained by the Eclipse Foundation within the
scope of Eclipse Tools Project. EMF started out as an implementation of the OMG
Meta Object Facility (MOF) specification, and evolved into a highly efficient
product for model-based software design.

EMF requires a metamodel as an input; it can import metamodels from different
sources, such as Rational Rose, XMI or XML Schema documents, or a special syntax
can be used to annotate existing Java source files with EMF model properties.
Once an EMF model is specified, the built-in code generator can create a
corresponding set of Java implementation classes.
These generated classes can be edited to add methods and instance variables;
additions will be preserved during code-regeneration. In addition to simply
increasing productivity, building an application using EMF provides several
other benefits like model change notification, persistence support including
default XMI and schema-based XML serialization, a framework for model
validation, and a very efficient reflective API for manipulating EMF objects
generically. Most important of all, EMF provides the foundation for
interoperability with other EMF-based tools and applications.

EMF consists of two fundamental frameworks: the core framework and EMF.Edit. The
core framework provides basic generation and runtime support to create Java
implementation classes for a model.

EMF has a built-in serialization facility, which enables the developer to save
(and load) in-stances of the model into industry-standard XMI format. EMF also
provides a notational and persistence mechanism, on top of which
model-manipulating tools can easily be constructed.


\subsubsection{EMF-IncQuery} 
Incremental model queries over emf models. Documentation site.
% https://viatra.inf.mit.bme.hu/incquery/documentation

\subsection{Other related technologies}

\subsubsection{Spring Framework}
%
The Spring Framework is an open source application framework and Inversion of
Control container for the Java platform. The core features of the Spring
Framework can be used by any Java application, but there are extensions for
building web applications on top of the Java EE platform. Although the Spring
Framework does not impose any specific programming model, it has become popular
in the Java community as an alternative to, replacement for, or even addition to
the Enterprise JavaBean (EJB) model.

%
The main advantage of using Spring framework is a configurability through
dependency injection. 


\subsubsection{Maven}
Build tool for Java projects. done by apache Same purpose as ant, but different
concept.
Standardize the build process by defining goals for building.
Defining project is done via descriptor xml containing a POM (Project object
model).
Pom can be used to configure the entire build process, but he most important part
is: dependency management, build customization,

Maven is customizable via plugins which can be done

Maven comes with a definition of a repository management. A maven repository can
be attached to the process


\subsubsection{Tycho}
Tycho is a set of Maven plugins and extensions for building Eclipse plugins and
OSGi bundles with Maven. It exists because Eclipse plugins have their own way of
describing metadata such as version numbers and dependencies which normally
would be placed in the Maven POM. Tycho reuses this native metadata 
and uses the POM to configure and drive the build. Tycho also knows
how to run JUnit test plugins using OSGi runtime and there is also support for
sharing build results using Maven artifact repositories. Tycho introduces
new packaging types and the corresponding lifecycle bindings that allow Maven to
use OSGi and Eclipse metadata during a Maven build.

Although Tycho is useful for building Eclipse plugins in a headless way but it
still has not reached the production quality (the current version number is
0.16) and it is still under heavy development. The current modifications and
enchantments can be found on the project's website.


\subsubsection{Oracle database}
The Oracle Database (also known as Oracle DB, Oracle RDBMS or just Oracle) is a
relational database management system (RDBMS) from the Oracle Corporation.
Originally developed in 1977 by Lawrence Ellison and other developers, Oracle DB
is one of the most trusted and widely-used relational database engines.

The system is built around a relational database framework in which data objects
may be directly accessed by users (or an application front end) through
structured query language (SQL). Oracle is a fully scalable relational database
architecture and is often used by global enterprises, which manage and process
data across wide and local area networks. The Oracle database has its own
network component to allow communications across networks.


\section{Example: Service Provider Framework}

To make the following chapters easier to understand, I am going to introduce a
simple use-case example. It is a design pattern called Service Provider
Framework. It is a practical application of the original Adapter pattern and it
was described in the famous book ,,Effective Java'' \cite{Bloch08}. This pattern
is the simplified version how the Java Database Connectivitz (JDBC) works.

\picr{exampleclasses.pdf}{Structure of Service Provider Framework pattern}

You can see the structure of the pattern on figure
\autoref{fig:exampleclasses.pdf}. As of the packages it contains 3 major parts.
The \code{service} package contains the core pattern classes. The \code{impl}
and the \code{impl} packages are external users of the pattern and therefore
they are considered depending client libraries.

First let's discuss the pattern itself. The main goal for the patter is to
provide a registry of implementations for a desired service. This service is
described in the \code{Service} interface. The \code{Provider} interface is
serves as a factory instance; it has a single function to instantiate a new
Service object. The \code{Services} class has the role of the registry.
The service implementers register their implementation using the static
\code{registerProvider()} and \code{registerDefaultProvider()} methods. The
parameters the identifier string for the registered service and Provider
instance which will instantiate the Service instances. The clients will
instantiate the Service instance with the \code{newInstance()} function.
Depending the passed identifier string, the method will look up if a Provider
was registered with the same name, and if the answer is yes then it calls the
\code{Provider.newInstance()} and return its result.

The \code{DEFAULT\_PROVIDER\_NAME} is a static public field which can be used to
obtain the default Service implementation. The \code{AbstractService} is a
utility class which implements one of the function of the Service interface.

The \code{impl} package contains one possible implementation to use the
described pattern. The \code{BasicService} contains the implementation and the
\code{BasicProvider} is responsible for properly initializing and returning a
new instance of this version. The \code{BasicImplUtil} -- as its name implies --
holds utility classes which register the implementation in the Services class.

The \code{client} package holds one single \code{Main} class, which contains a
simple evaluation. It invokes the \code{Services.newInstance()} function passing
the default provider's name as an argument and invokes the \code{serviceA()} and
\code{serviceB()} function.

Although the example is fairly simple, the source code can be found in appendix A.

So why are we looking at this example? Imagine that the three packages are
distributed into three different software which have their individual
responsible developer. Now let's say, somebody wants to change some parts of the
service without preciesly knowing who is using which part of the code. Not this
will be our example which I will use to present how my software works and how
can this problem be solved by it.




