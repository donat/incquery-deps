\chapter{Background}
%------------------------------------------------------------------------------
%10 pages. For motivation: Design pattern figure. (Service registration pattern).
%------------------------------------------------------------------------------

\section{Related technologies}
% Why do we need this part.
Before proceeding to the main part of this paper, I am going to give an overview
about the related technologies used by my solution. I Why do we have to present
the related technologies.

\subsection{Java Runtime}

\subsubsection{Java byte code specification}
% Java language
The Java \cite{JavaSpec} programming language is a general-purpose, concurrent,
object-oriented language. Its syntax is similar to C and C++, but it omits many
of the features that make C and C++ complex, confusing, and unsafe. The Java
platform was initially developed to address the problems of building software
for networked consumer devices. It was designed to support multiple host
architectures and to allow secure delivery of software components. To meet these
requirements, compiled code had to survive transport across networks, operate on
any client, and assure the client that it was safe to run.

% Java Virtual machine
The Java virtual machine is an abstract computing machine. Like a real computing
machine, it has an instruction set and manipulates various memory areas at
runtime. It is reasonably common to implement a programming language using a
virtual machine. The Java virtual machine knows nothing of the Java programming
language, only of a particular binary format, the  \code{class} file format. A
\code{class} file contains Java virtual machine instructions (or 
\emph{bytecodes}) and a symbol table, as well as other ancillary information.

% What is a class file
The class file format is a hardware- and operating system-independent binary
format which is executed by the virtual machine. Typically (but not necessarily)
stored in a file. The class file format precisely defines the representation of a
class or interface, including details such as byte ordering that might be taken
for granted in a platform-specific object file format.

% How is a class file used.
\pic{compilation.pdf}{Compilation and execution of Java classes}
Figure \autoref{fig:compilation.pdf} illustrates the procedure of compiling and
executing a Java class: The source file is compiled into a Java class file,
loaded by the byte code interpreter and executed. In order to implement
additional features, researchers may want to transform class files (drawn with
bold lines) before they get actually executed.
This application area is one of the main issues of this article.

% Internals of the class file
\pic{classfile.pdf}{Simplified structure of a class file}
Figure \autoref{fig:classfile.pdf} shows a simplified example of the contents of a
Java class file: It starts with a header containing a "magic number"
(0xCAFEBABE) and the version number, followed by the constant pool, which can be
roughly thought of as the text segment of an executable, the access rights of
the class encoded by a bit mask, a list of interfaces implemented by the class,
lists containing the fields and methods of the class, and finally the class
attributes, e.g., the SourceFile attribute telling the name of the source file.
Attributes are a way of putting additional, user-defined information into class
file data structures. For example, a custom class loader may evaluate such
attribute data in order to perform its transformations. The JVM specification
declares that unknown, i.e., user-defined attributes must be ignored by any
Virtual Machine implementation.
 
\subsubsection{Apache Commons Byte Code Engineering Library}
% described in the virtual machine specification 
% http://docs.oracle.com/javase/specs/jvms/se5.0/html/VMSpecTOC.doc.html 
% how the virtual machine works
% what kind of infomration is available in the bytecode 
\cite{BCEL}
Abstraction over Java byte code specification. 
How it works. Create diagram!
Possible use-cases.


\subsection{Eclipse}

\subsubsection{Eclipse Integrated Development Environment}
The Eclipse Project \cite{Eclipseproject} is an open source software development
project dedicated to providing a robust, full-featured, commercial-quality,
industry platform for the development of highly integrated tools. It was
developed by IBM from 1999, and a few months after the first version was
shipped, IBM donated the source code to the Eclipse Foundation.

The Eclipse project consists of many subprojects, the most important being the
Eclipse Platform, that defines the set of frameworks and common services that
collectively make up ,,integration-ware'' required to support a comprehensive
tool integration platform. These services and frameworks represent the common
facilities required by most tool builders, including a standard workbench user
interface and project model for managing resources, portable native widget and
user interface libraries, automatic resource delta management for incremental
compilers and builders, language-independent debug infrastructure, and
infrastructure for distributed multi-user versioned resource management.

The Eclipse Platform has an easily-extendable modular architecture, where all
functionality is achieved by plugins, running over a low-level core called
Platform Runtime. This runtime core is only responsible for loading and
connecting the available plugins, every other functionality, such as the
editors, views, project management, is handled by plugins. The plugins bundled
with Eclipse Platform include general user interface components, a common help
system for all Eclipse components, project management and team work support.

\subsubsection{Eclipse Java Development Tools}
The Eclipse Java Development Tools (JDT) project \cite{JDT} contributes a set of
plugins that add the capabilities of a full-featured Java IDE to the Eclipse
platform. The JDT plugins provide APIs so that they can themselves be further
extended by other tool builders. The JDT plugins are categorized into five main
projects: Annotation Processing (APT), Core, Debug, Text, and User Interface
(UI).

The most important part -- in the context of this paper -- is the Core project
which implements all the necessary non-UI infrastructure for developing Java
applications on the Eclipse platform. It contains an incremental Java builder,
support for code assist, a searching facility and a \emph{Java Model}, that
provides API for navigating the Java element tree. This lets the contributors
access the structure and the changes of the java applications loaded into the
workspace.

\subsubsection{Eclipse Modeling Framework}
The Eclipse Modeling Framework (EMF) \cite{EMF} is a Java framework and code
generation facility for building tools and other applications based on a
structured model. EMF is also maintained by the Eclipse Foundation within the
scope of Eclipse Tools Project. EMF started out as an implementation of the OMG
Meta Object Facility (MOF) specification, and evolved into a highly efficient
product for model-based software design.

EMF requires a metamodel as an input; it can import metamodels from different
sources, such as Rational Rose, XMI or XML Schema documents, or a special syntax
can be used to annotate existing Java source files with EMF model properties.
Once an EMF model is specified, the built-in code generator can create a
corresponding set of Java implementation classes.
These generated classes can be edited to add methods and instance variables;
additions will be preserved during code-regeneration. In addition to simply
increasing productivity, building an application using EMF provides several
other benefits like model change notification, persistence support including
default XMI and schema-based XML serialization, a framework for model
validation, and a very efficient reflective API for manipulating EMF objects
generically. Most important of all, EMF provides the foundation for
interoperability with other EMF-based tools and applications.

EMF has a built-in serialization facility, which enables the developer to save
(and load) in-stances of the model into industry-standard XMI format. EMF also
provides a notational and persistence mechanism, on top of which
model-manipulating tools can easily be constructed.


\subsubsection{EMF-IncQuery} 
% Problem to solve.
Working with models it is quite common to query the model for checking and
validating certain properties. The EMF-IncQuery \cite{EMFIncQuery} tool provides
one solution for this problem: it is a framework to execute fast model queries
over EMF models. It is actively developed at Budapest University of Technology
and Economics. Although it is still in development status (the current
version is 0.6.0) it already proved its usability through industrial use-cases
and university researches.

% Core.
The core of the framework is a query evaluator engine built on top of graph
pattern matching engine using RETE \cite{RETE} algorithm adapted from expert
systems to facilitate the efficient storage and retrieval of partial views of
graph-like models. In a nutshell RETE maintains a hierarchical query data
structure on top of the model which stores the result of sub-queries. On model
change, the event propagates through this data structure leaving the unmodified
part of the model untouched. This results in fast, near zero response time and
size-independence on small model change. In return the model and the query
structure has to be loaded into the memory which can be a significant resource
expense.

% API.
To access the capabilities of the core, an easy-to-use, type safe API is
defined. Using the API, EMF resources and object hierarchies can be loaded and
queried incrementally. In addition certain extensions -- such as the validation
framework -- can be attached.

% Query lanuage.
Along the API, a complete query language is defined. It provides a declarative
way to express the queries over the EMF model in a form of patterns. With the
language the user can express combined queries, negative patterns, checking
property conditions, simple calculations, calculate disjunctions and transitive
closures, etc.

% Tooling.
The framework comes with a rich UI tooling which helps the users to effectively
develop test and integrate queries into their solution. The first element of the
tooling is the rich XText based editor for the query language which aids writing
well formed queries providing content assist, error markings and such. The next
part of the tooling is the ability to load EMF models and execute the queries on
them as the user writes them giving rich visual feedback about the result.
The last important part is the code generation. The tooling dynamically
generates the source code which contains the programmatic equivalent of the
model queries. The users can integrate this code out of the box in Eclipse
plugins as well as headless applications to execute queries and get back the
results from the source code level.

\subsection{Other related technologies}

\subsubsection{Spring Framework}
%
The Spring Framework is an open source application framework and Inversion of
Control container for the Java platform. The core features of the Spring
Framework can be used by any Java application, but there are extensions for
building web applications on top of the Java EE platform. Although the Spring
Framework does not impose any specific programming model, it has become popular
in the Java community as an alternative to, replacement for, or even addition to
the Enterprise JavaBean (EJB) model.

%
The main advantage of using Spring framework is a configurability through
dependency injection. 


\subsubsection{Maven}
Build tool for Java projects. done by apache Same purpose as ant, but different
concept.
Standardize the build process by defining goals for building.
Defining project is done via descriptor xml containing a POM (Project object
model).
Pom can be used to configure the entire build process, but he most important part
is: dependency management, build customization,

Maven is customizable via plugins which can be done

Maven comes with a definition of a repository management. A maven repository can
be attached to the process


\subsubsection{Tycho}
Tycho is a set of Maven plugins and extensions for building Eclipse plugins and
OSGi bundles with Maven. It exists because Eclipse plugins have their own way of
describing metadata such as version numbers and dependencies which normally
would be placed in the Maven POM. Tycho reuses this native metadata 
and uses the POM to configure and drive the build. Tycho also knows
how to run JUnit test plugins using OSGi runtime and there is also support for
sharing build results using Maven artifact repositories. Tycho introduces
new packaging types and the corresponding lifecycle bindings that allow Maven to
use OSGi and Eclipse metadata during a Maven build.

Although Tycho is useful for building Eclipse plugins in a headless way but it
still has not reached the production quality (the current version number is
0.16) and it is still under heavy development. The current modifications and
enchantments can be found on the project's website.


\subsubsection{Oracle database}
The Oracle Database (also known as Oracle DB, Oracle RDBMS or just Oracle) is a
relational database management system (RDBMS) from the Oracle Corporation.
Originally developed in 1977 by Lawrence Ellison and other developers, Oracle DB
is one of the most trusted and widely-used relational database engines.

The system is built around a relational database framework in which data objects
may be directly accessed by users (or an application front end) through
structured query language (SQL). Oracle is a fully scalable relational database
architecture and is often used by global enterprises, which manage and process
data across wide and local area networks. The Oracle database has its own
network component to allow communications across networks.


\section{Example: Service Provider Framework}

To make the following chapters easier to understand, I am going to introduce a
simple use-case example. It is a design pattern called Service Provider
Framework. It is a practical application of the original Adapter pattern and it
was described in the famous book ,,Effective Java'' \cite{Bloch08}. This pattern
is the simplified version how the Java Database Connectivity (JDBC) works.

\picr{exampleclasses.pdf}{Structure of Service Provider Framework pattern}

You can see the structure of the pattern on figure
\autoref{fig:exampleclasses.pdf}. As of the packages it contains 3 major parts.
The \code{service} package contains the core pattern classes. The \code{impl}
and the \code{impl} packages are external users of the pattern and therefore
they are considered depending client libraries.

First let's discuss the pattern itself. The main goal for the patter is to
provide a registry of implementations for a desired service. This service is
described in the \code{Service} interface. The \code{Provider} interface is
serves as a factory instance; it has a single function to instantiate a new
Service object. The \code{Services} class has the role of the registry.
The service implementers register their implementation using the static
\code{registerProvider()} and \code{registerDefaultProvider()} methods. The
parameters the identifier string for the registered service and Provider
instance which will instantiate the Service instances. The clients will
instantiate the Service instance with the \code{newInstance()} function.
Depending the passed identifier string, the method will look up if a Provider
was registered with the same name, and if the answer is yes then it calls the
\code{Provider.newInstance()} and return its result.

The \code{DEFAULT\_PROVIDER\_NAME} is a static public field which can be used to
obtain the default Service implementation. The \code{AbstractService} is a
utility class which implements one of the function of the Service interface.

The \code{impl} package contains one possible implementation to use the
described pattern. The \code{BasicService} contains the implementation and the
\code{BasicProvider} is responsible for properly initializing and returning a
new instance of this version. The \code{BasicImplUtil} -- as its name implies --
holds utility classes which register the implementation in the Services class.

The \code{client} package holds one single \code{Main} class, which contains a
simple evaluation. It invokes the \code{Services.newInstance()} function passing
the default provider's name as an argument and invokes the \code{serviceA()} and
\code{serviceB()} function.

Although the example is fairly simple, the related source code can be found in
appendix \autoref{examplesource}.

So why are we looking at this example? Imagine that the three packages are
distributed into three different software which have their individual
responsible developer. Now let's say, somebody wants to change some parts of the
service without precisely knowing who is using which part of the code. Not this
will be our example which I will use to present how my software works and how
can this problem be solved by it. 


