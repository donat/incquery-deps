\chapter{Overview}
% ------------------------------------------------------------------------------
% 3 pages. Super figure which describes the entire solution. Choosing proper
% abstraction level for the %figure is essential. Every item on this figure will
% be an additional chapter in this paper.
% TODO:find a proper name for this chapter.
% ------------------------------------------------------------------------------

\section{Structure}
% My implementation.
As it was discussed previously one of the most effective  way of achieving
smooth upgrades is to discover incoming dependencies. For this I designed and
implemented a solution called \ptool{}. \picr{superfigure.pdf}{Overview of the
implemented system} Figure \autoref{fig:superfigure.pdf} shows the overview of
it.

% CERN-related.
% NOTE, that the current implementation is bound to the CERN Control system's
% infrastructure. All used source and the way of getting them described by the
% internals. Let alone this fact, it is fairly simple to change the implementation
% to be usable in an arbitrary environment because only a tiny part of the code is
% responsibe to retrieve the required resources.

% Two implementation
This systems was implemented in two separate steps. My work at CERN covered an
implementation of a system which gives the ability to the users to query certain
parts of the source code for incoming dependencies. After my job was done I
created an extension which utilizes EMF-IncQuery to run faster, information-rich
and more extensive queries. Let's examine the elements of the figure one-by-one.

\subsection{Central repository management}
% Central repository management.
The first element on the figure is the ,,Central repository management''. It
refers all the internal resources CERN Control systems contains. Its central
element is a tool called \tool{Common Build} which is a build tool for Java
softwares. Common Build is an Apache Ant based software similar to Maven. It
provides functionality to describe and resolve dependencies, build, generate
documentation and release the softwares\footnote{Or \textit{products} as they
are referred at CERN}. The released softwares are put into a binary repository
which has a well-defined layout. On top of it, source repository is tightly
attached to the release repository; there is a 1-1 relationship between the
source code and the binaries.

\subsection{The server side}
The server side is a standalone Java application which runs on a Linux server.
It has two functionality: 1) it discovers and stores the structure of the
products and 2) provides an interface for serving dependency queries. 

For discovering, the process listens if a new release happens in the repository.
If it happens the freshly added binaries (jar files) are passed to the byte code
analysis module which parses the file and discovers the contained structure and
the dependencies utilizing the Apache BCEL library.  The structure and the
dependencies are passed to the storage engine to store it. The storage engine
itself defines a set of operations to find, store and retrieve certain subset of
the model. The remote query interface also use this module to get the necessary 
dependency information for the clients.

\subsection{The client side}
% Plugin
The client-side of the solution is an Eclipse plugin (or more precisely a set of
plugins) which gives the developer a convenient way to access to the dependency
information.

% Model load and direct queries
The base of the plugin is the repository model loader. It provides a simple API
for accessing and querying the dependency information from the server. The
simple use-case for this, when the user directly asks the dependency information
from the Java source editor through UI contribution (marked as direct queries on
the figure).

% ws model creator
The workspace model creator is module generating an EMF model describing the
state of the workspace. The generated model contains the loaded projects, the
contained packages, classes, methods, etc. The model also contains the
dependency structure between the elements (e.g. method calls, field accesses and
such). The information is gathered through the Eclipse Java Development Tools'
API. After the model is created it is incrementally maintained even through 
restarts.

% pattern maching over.
The pattern matcher module executes complex model queries on top of the acquired
models to provide dependency information. First it loads an EMF model from the
server describing the structure of all projects in the central repository.
Afterward the workspace model is loaded from the module described above. Both of
the models are loaded to the EMF-IncQuery engine. Through complex queries the two
models are joined and queried for the dependency information. With this more 
accurate and extensive dependency analysis can be achieved because this approach
takes into account the changes which were done in the workspace. The workspace 
model is updated upon every change of the workspace giving up-to-date feedback 
for the users while they are working on the development. 

% Interface.
Both direct queries and the pattern matching module return the result in Eclipse 
views. After the result is evaluated, the user's responsibility to evaluate their
results and act accordingly.

% limitation.
Using direct queries brings no limitations. The queries are simple remote method
calls and the result set is a relatively small data set which easy to store and
present on the Eclipse UI. On the other hand, the pattern matching solution is
far from being that easy, because in order to load make EMF-IncQuery work, the
entire repository has to be loaded. By default this model is a few hundred
megabytes sized in a serialized form. This implies that the implementation has to 
optimize this model without dropping useful information to make it loadable to 
the memory.