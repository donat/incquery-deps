\chapter{Evaluation}
%------------------------------------------------------------------------------
%3-4 pages. Functional evaluation. Performance evaluation. 
%------------------------------------------------------------------------------

\section{Example revisited}

After showing the details of the implementation, let's see it in action.
We will use the tool to solve the problem described in \autoref{sect:spf}. We
will go though on every component and check what is happening there with the
example. 

Let's start with the repositories. In our example the source and the binary
repository contains three projects, each of them holds one package from the
example. the name of the projects are service, client and impl, the name of 
the jars files respectively service.jar, client.jar and impl.jar. For the sake
of simplicity we have only one version from each project. 

\subsection{On the server side}


Now let's move forward to the server process and the dependency analysis. As 
the binary projects appear in the repository, they get discovered by the 
server process. 

The first step in the process is the bytecode analysis. In this phase the
structure and the reference of the dependencies are discovered from the
binaries. As of the structure the analyzer finds 3 projects, 8 classes 2 fields
and 19 methods which get stored in the database.
The methods are composed of the 12 defined methods, 6 constructor (from all
non-interface classes) and 1 static initializer (which comes from the Services
class as it gives a default value to a static field). 

The discovered dependencies are formatted and filtered in order not to have
internal or platform defined elements (dependencies pointing inside the
\code{java.*} package). For example let's see the \code{BasicImplUtil} class'
\code{registerImplementation()} method.
\begin{tabl}
{External references of the BasicImplUtil.registerImplementation() method}
{extrefs}{|p{.37\linewidth}|p{.37\linewidth}|p{.2\linewidth}|}
\hline
	\textbf{Binary format}						&  
	\textbf{Source format} 						& 
	\textbf{Type} 								\\
\hline
	impl/BasicProvider  						&
	impl.BasicProvider 							&
	ConstClass 									\\
\hline
	service/Services/registerProvider 
	\mbox{(Ljava/lang/String;}
	\mbox{Lservice/Provider;)V} 				& 
	\mbox{service.Services.registerProvider}
	\mbox{(java.lang.String,}
	\mbox{service.Provider):void} 				&
	\mbox{Constant} \mbox{MethodRef} 			\\
\hline
\end{tabl}
The first one is a 
\code{ConstantMethodRef} type reference. During the analysis they are first converted
The first one is a class reference the second one is a method reference.
The references are formatted to source format as it is shown in the second column.
Now the first references is eliminated from the list, because it points inside the 
\code{impl} project. However the second one does not, so it remains at its place.  

The dependency processor takes the remaining dependencies from the elements and 
searches the database if there is one. In case of our method reference, the processor
finds that there is a \code{registerProvider()} method defined with the same exact 
signature signature in the database. Because the reference was stored on the called 
method list, the processor creates a new method call dependency starting from 
\code{impl.BasicImplUtil} targeting \code{Services.registerProvider()}.

At this point the storage engine stores all the structure and the dependencies 
of the three products. The schema of the Oracle database implementation and the EMF
database was described in details previously. Now let's check how this data can be used 
on the client side.

\subsection{On the client side}

To continue our example, we will examine the view of the developer who knows
only about his own \code{service} project. If the \ptool{} is  installed in his
Eclipse, the EMF model -- shown on \autoref{fig:wsmodel.png}
\picr{wsmodel.png}{Workspace model containing Service package from the example}
-- is built and synchronized automatically. On the figure we can see, that the
structure of the project (left) corresponds to the content of the EMF model
(right). In the model view, you can also see that the in-project dependency
relationships are also registered.


Because the \code{client} and the \code{impl} projects have references to the
\code{service} project, both of them are loaded to the repository model. It has all the
element but with the compacted version, so no fully qualified names. But because
there is no overlapping names between the classes and method than the compacted
model does not introduce false-positive results.

Let's see how the developer checks the incoming dependencies through the
explicit queries.
\pic{incdeps.png}{Execute explicit queries from the source code editor}
\autoref{fig:incdeps.png} shows the context menu contribution for initiating an
explicit query. The query takes a few seconds to respond. The results are shown
in the viewer like on \autoref{fig:results.png}.
\picr{results.png}{Result of explicit queries}
 
The same result can be retrieved using model queries, but without any
interaction: all result for the selected project is automatically showed. Plus,
if something is changed, for example the \code{serviceB()} method is deleted, it
i) is compared against the repository model and marked as deleted method and all
the incoming dependencies is listed as a possible impact if the modified code
gets committed. 
\todo[inline]{put image of the result of the model queries}

Back to example. The developer checks the incoming dependencies of the
\mbox{\code{Services.}} \mbox{\code{DEFAULT\_PROVIDER\_NAME}} field and the \code{Service.serviceA()}
method. In the first case there are some incoming dependencies which can be
examined.
In our example there are two external users of the field, so the developer can
either contact them and coordinate the smooth upgrades by simultaneously
releasing a new versions of all projects. On the other side, the
\code{serviceA()} method has no incoming dependencies, as nobody uses it. In
this case the developer has the right to change the signature however he wants.


\section{Performance evaluation}
Check performance of the system we have to check the following use-cases.
 * the dependency discovery is fast enough to process large number of jars
 * can it scale well with the size of the input
 * explicit queries: what is the response time of the queries. 
 * model queries: how big model can fit into memory. bottleneck to  
 
Data input is real word
 * Not generated.
 * CERN softwares.
 * Operationonal 
 
Server side:
 * Question: How efficient the dependency discovery.
 * Specification of the test machine: cern hyperv vm. win 7 enterprise 32 bit, 4gig ram. Typical machine sw dev.
 * Circumstances 
 * Input data: subset of the binaries (1300 jars). Check many elements, and how big model is saved.
%\todonotes{Insert picture and analyse the values. The measurement is running right now.}
 * Verdict: scale well to huge database. manageable model size.
 
Explicit queries:
 * server process is on the same machine, client separately.
 * 100 random c-m-f selected randomly from the database. 
 * client checks how fast the server reacts. Peak, minimum, average.
 * Verdict: reasonable response time, reliable.
 \pic{expqmeasure.pdf}{Explicit queries measurement result}
 
Model queries:
 * Eclipse involved: hard to query the performance of individual plugins.
 * Simple use-case: how big model can fit into the memory without having
 performance penalties.
 * Practical, the overall memory consumption counts anyway.
 * input:repository model transformed into the compacted model.
 * measure:
   * original size. compacted size. load model size. initialization time. heap
   size. reaction time.
 * Verdict: Loading huge model but if  software repository does not contain
 super projects, reasonable to load a subset which is small enough to  hold it
 in the db. In return extra fast. 
